#' @export
DR2Smap.default <- function(sample,
                            locus,
                            longreads = list(type = "pacbio", dir = "pacbio"),
                            shortreads = list(type = "illumina", dir = "illumina"),
                            datadir = ".",
                            outdir = ".",
                            reference = NULL,
                            consensus = "multialign",
                            threshold = 0.20,
                            fullname = TRUE,
                            create_outdir = TRUE,
                            ...) {
  conf <- create_dr2s_conf(
    sample = sample,
    locus = locus,
    longreads = longreads,
    shortreads = shortreads,
    datadir = datadir,
    outdir = outdir,
    reference = reference,
    consensus = consensus,
    threshold = threshold,
    fullname = fullname,
    ...
  )
  DR2S_$new(conf, create_outdir = create_outdir)
}

#' @export
DR2Smap.DR2Sconf <- function(sample) DR2S_$new(conf)

#' @export
cache.DR2S <- function(x, outname, ...) {
  if (missing(outname)) {
    outname <- paste("DR2S", x$getLrdType(), x$getMapper(), "rds", sep = ".")
  }
  x$cache(outname = outname)
  invisible(x)
}

#' @export
clear.DR2S <- function(x, ...) {
  x$clear()
  invisible(x)
}


# Class: DR2S -------------------------------------------------------------


#' Class \code{"DR2S"}
#'
#' @docType class
#' @usage DR2Smap(sample, locus, longreads = list(type = "pacbio", dir = "pacbio"),
#' shortreads = list(type = "illumina", dir = "illumina"), datadir = ".",
#' outdir = "./output", reference = NULL, consensus = "multialign",
#' threshold = 0.20, fullname = TRUE, create_outdir = TRUE, ...)
#' @field map0 \code{[map0]}; the mapping of long reads to \code{reference}.
#' @field partition \code{[PartList]}; the partitioning of full-length mapped
#'   long reads into two haplotypes A and B.
#' @field map1 \code{[map1]}; the mapping of A and B reads to reference sequences
#' generated by multiple alignment of a subset of A and B reads.
#' @field map2 \code{[map2]}; the mapping of A and B reads to consensus
#'   sequences produced in the previous step.
#' @field map3 \code{[map3]}; the mapping of A, B, and short reads to consensus
#'   sequences produced in the previous step.
#' @field consensus \code{[ConsList]}; final consensus sequences for A and B.
#'
#' @keywords data internal
#' @return Object of \code{\link{R6Class}} representing a DR2S analysis.
#' @section Public Methods:
#' \describe{
#' \item{\code{x$runMap0(opts = list(), optsname = "", pct = 100, threshold = 0.20,
#' min_base_quality = 3, min_mapq = 0, max_depth = 1e4, min_nucleotide_depth = 3,
#' include_deletions = FALSE, include_insertions = FALSE, force = FALSE,
#' fullname = TRUE, plot = TRUE)}}{
#' Run the inital mapping step (long reads against the reference allele)}
#' \item{\code{x$runHaplotypePartitioning(max_depth = 1e4, shuffle = TRUE,
#' skip_gap_freq = 2/3, plot = TRUE)}}{
#' Partition mapped long reads into haplotypes}
#' \item{\code{x$splitReadsByHaplotype(limit = list(), #' plot = TRUE)}}{
#' Partition mapped long reads into haplotypes}
#' \item{\code{x$extractFastq(nreads = NULL, replace = FALSE, nalign = 30)}}{
#' Extract FASTQs for partitioned reads and if the consensus method is
#' \code{multialign} contruct a multiple sequence alignment from the best
#' \code{nalign} reads.}
#' }
#' @section Internals:
#' \describe{
#' \item{\code{x$new(conf, create_outdir = TRUE)}}{Initialise object of class
#'  \code{DR2S}.}
#' \item{x$getConfig(name = NULL}{Extract configuration}
#' \item{x$setConfig(name, value}{Modify configuration}
#' }
DR2S_ <- R6::R6Class(
  classname = "DR2S",
  public = list(
    ## Mapping of pacbio/nanopore reads to $ref
    ## class: map0 (list)
    ## map0
    ##   $reads [character]
    ##   $samfile [character]
    ##   $bamfile [character]
    ##   $pileup [pileup]
    ##   $tag [character]
    map0 = list(),
    ## partitioning of full-length mapped reads into two haplotypes A and B
    ## class: PartList (list)
    ## partition
    ##   $mat [matrix<factor>]
    ##   $prt [HapPart]
    ##   $hpl [HapList]
    ##   $limplt [ggplot2]
    partition = list(),
    ## Remapping of A and B reads to $ref and $alt and construction of
    ## $map1$A$conseq and $map1$B$conseq
    ## class: map1 (list)
    ## map1
    ##   $A
    ##   $B
    ##     $dir [character]
    ##     $reads [character]
    ##     $ref [character] Path to reference fasta
    ##     $bamfile [list]
    ##       $reference [character]
    ##       $alternate [character]
    ##     $pileup [list]
    ##       $reference [pileup]
    ##       $alternate [pileup]
    ##     $conseq [list]
    ##       $reference [BStringSet]
    ##       $alternate [BStringSet]
    ##       $merged [BStringSet]
    ##     $seqpath [list]
    ##       $reference [character]
    ##       $alternate [character]
    ##       $merged [character]
    ##     $tag [list]
    ##       $reference [character]
    ##       $alternate [character]
    ##       $merged [character]
    map1 = list(
      A = list(),
      B = list()
    ),
    ## Remapping of A and B reads to $map1$A$conseq and $map1$B$conseq
    ## and construction of $map2$A$conseq and $map2$B$conseq
    ## class: map2
    ## map2
    ##   $A
    ##   $B
    ##     $dir [character]
    ##     $reads [character]
    ##     $ref [character]
    ##     $bamfile [character]
    ##     $pileup [pileup]
    ##     $conseq [BStringSet]
    ##     $seqpath [character]
    ##     $tag [character]
    map2 = list(
      A = list(),
      B = list()
    ),
    ## Mapping of short reads and long reads to $map2$A$conseq and $map2$B$conseq
    ## class: map3
    ## map3
    ##   $dir [character]
    ##   $sreads [character]
    ##   $areads [character]
    ##   $breads [character]
    ##   $aref [character]
    ##   $bref [character]
    ##   $bamfile [list]
    ##     $LRA [character]
    ##     $LRB [character]
    ##     $SRA [character]
    ##     $SRB [character]
    ##   $pileup [list]
    ##     $LRA [pileup]
    ##     $LRB [pileup]
    ##     $SRA [pileup]
    ##     $SRB [pileup]
    ##   $tag [list]
    ##     $LRA [character]
    ##     $LRB [character]
    ##     $SRA [character]
    ##     $SRB [character]
    map3 = list(),
    ## Final consensus sequences for A and B
    ## class: ConsList
    consensus = list(),
    initialize = function(conf, create_outdir = TRUE) {
      ## Public fields
      self$map0      = list()
      self$partition = list()
      self$map1      = list(A = list(), B = list())
      self$map2      = list(A = list(), B = list())
      self$map3      = list()
      self$consensus = list()
      ## Private fields
      ## undebug(DR2S:::initialise_dr2s)
      private$conf   = initialise_dr2s(conf, create_outdir = create_outdir)
      private$ipd    = findLocus(private$conf$locus)
      if (is.null(private$conf$reference)) {
        private$conf$reference = "consensus"
        private$conf$ref_path  = generate_reference_sequence(private$ipd, "consensus", private$conf$outdir)
      }
      else {
        if (file.exists(ref_path <- private$conf$reference)) {
          private$conf$reference = basename(ref_path)
          private$conf$ref_path  = normalizePath(ref_path, mustWork = TRUE)
        } else {
          private$conf$reference = expand_hla_allele(conf$reference, conf$locus)
          private$conf$ref_path  = generate_reference_sequence(private$ipd, private$conf$reference, private$conf$outdir, fullname = TRUE)
        }
      }
      if (is.null(private$conf$alternate)) {
        private$conf["alternate"] = list(NULL)
      }
      else {
        if (file.exists(alt_path <- private$conf$alternate)) {
          private$conf$alternate = basename(alt_path)
          private$conf$alt_path  = normalizePath(alt_path, mustWork = TRUE)
        } else {
          private$conf$alternate = expand_hla_allele(private$conf$alternate, private$conf$locus)
          private$conf$alt_path  = generate_reference_sequence(private$ipd, private$conf$alternate, private$conf$outdir, fullname = TRUE)
        }
      }
      private$conf$A_reftype = NA
      private$conf$B_reftype = NA
    },
    cache = function(outname) {
      if (missing(outname)) {
        outname <- paste("DR2S", self$getLrdType(), self$getMapper(), "rds", sep = ".")
      }
      path <- file.path(self$getOutdir(), outname)
      message("\nCaching ", dQuote(path), "\n")
      saveRDS(self$clone(deep = TRUE),
              file = path,
              compress = TRUE)
      invisible(self)
    },
    clear = function() {
      unlink(self$getOutdir(), recursive = TRUE)
      dir_create_if_not_exists(file.path(self$getOutdir()))
      if (!is.null(private$ipd)) {
        private$conf$ref_path = generate_reference_sequence(self$getIPD(), self$getReference(), self$getOutdir(), fullname = TRUE)
        private$conf$alt_path = generate_reference_sequence(self$getIPD(), self$getAlternate(), self$getOutdir(), fullname = TRUE)
      }
      invisible(self)
    },
    cleanup = function() {
      unlink(self$map0$bamfile)
      unlink(paste0(self$map0$bamfile, ".bai"))
      unlink(file.path(self$getOutdir(), "A"), recursive = TRUE)
      unlink(file.path(self$getOutdir(), "B"), recursive = TRUE)
      unlink(file.path(self$getOutdir(), "merged"), recursive = TRUE)
      invisible(self)
    },
    print = function() {
      fmt0 <- "DR2S mapper for sample <%s> locus <%s>\n"
      cat(sprintf(fmt0, self$getSampleId(), self$getLocus()))
      fmt1 <- "Reference alleles: <%s%s>\nLongreads: <%s> Shortreads: <%s>\nMapper: <%s>\nDatadir: <%s>\nOutdir: <%s>\n"
      cat(sprintf(fmt1,
        self$getReference(),
        if (is.null(self$getAlternate())) "" else paste0(", ", self$getAlternate()),
        self$getLrdType(), self$getSrdType(), self$getMapper(), self$getDatadir(), self$getOutdir()
      ))
      invisible(self)
    },
    ##
    ## Getters and Setters ####
    ##
    getConfig = function(name = NULL) {
      if (is.null(name))
        private$conf
      else
        private$conf[[name]]
    },
    ##
    setConfig = function(name, value) {
      private$conf[name] = value
      invisible(self)

    },
    ##
    getDatadir = function() {
      self$getConfig("datadir")
    },
    ##
    getOutdir = function() {
      self$getConfig("outdir")
    },
    ##
    getThreshold = function() {
      self$getConfig("threshold")
    },
    ##
    setThreshold = function(threshold) {
      stopifnot(threshold > 0 && threshold <= 1)
      self$setConfig("threshold", threshold)
      invisible(self)
    },
    ##
    getLongreads = function() {
      dir <- self$getLrdDir()
      readpath <- findReads(dir, self$getSampleId(), self$getLocus())
      if (is.null(readpath) || length(readpath) == 0) {
        stop("No reads available for readtype <", self$getLrdType(), ">")
      }
      readpath
    },
    ##
    getShortreads = function() {
      dir <- self$getSrdDir()
      if (is.null(dir)) {
        return(NULL)
      }
      readpath <- findReads(dir, self$getSampleId(), self$getLocus())
      if (is.null(readpath) || length(readpath) == 0) {
        stop("No reads available for readtype <", self$getSrdType(), ">")
      }
      readpath
    },
    ##
    getMapper = function() {
      self$getConfig("mapper")
    },
    ##
    getLimits = function() {
      self$getConfig("limits")
    },
    ##
    setLimits = function(lmts) {
      ## Todo: add test for data consistency!
      private$conf$limits = lmts
      invisible(self)
    },

    # getLimitA = function() {
    #   self$getConfig("limitA")
    # },
    ##

    # setLimitA = function(lmt) {
    #   stopifnot(is.null(lmt) || lmt >= -1 && lmt <= 1)
    #   self$setConfig("limitA", lmt)
    #   invisible(self)
    # },
    # ##
    # getLimitB = function() {
    #   self$getConfig("limitB")
    # },
    # ##
    # setLimitB = function(lmt) {
    #   stopifnot(is.null(lmt) || lmt >= -1 && lmt <= 1)
    #   self$setConfig("limitB", lmt)
    #   invisible(self)
    # },
    ##
    getHapTypes = function() {
      self$getConfig("haptypes")
    },
    ##
    setHapTypes = function(x) {
      ## Todo: add test for data consistency!
      private$conf$haptypes = x
      invisible(self)
    },
    ##
    getPipeline = function() {
      self$getConfig("pipeline")
    },
    ##
    getLrdType = function() {
      self$getConfig("longreads")$type
    },
    ##
    getLrdDir = function() {
      file.path(self$getDatadir(), self$getConfig("longreads")$dir)
    },
    ##
    getSrdType = function() {
      self$getConfig("shortreads")$type
    },
    ##
    getSrdDir = function() {
      if (!is.null(srddir <- self$getConfig("shortreads")$dir)) {
        file.path(self$getDatadir(), srddir)
      } else {
        NULL
      }
    },
    ##
    getReftype = function() {
      self$getConfig("reftype")
    },
    ##
    getReference = function() {
      self$getConfig("reference")
    },
    ##
    getAlternate = function() {
      self$getConfig("alternate")
    },
    ##
    getSampleId = function() {
      self$getConfig("sample_id")
    },
    ##
    getLocus = function() {
      self$getConfig("locus")
    },
    ##
    getRefPath = function() {
      self$getConfig("ref_path")
    },
    ##
    getRefSeq = function() {
      if (!is.null(self$getIPD())) {
        if (self$getReference() == "consensus") {
          self$getIPD()$cons
        } else {
          self$getIPD()$get_reference_sequence(self$getReference())
        }
      } else {
        Biostrings::readDNAStringSet(self$getRefPath())
      }
    },
    ##
    getAltPath = function() {
      self$getConfig("alt_path")
    },
    ##
    getAltSeq = function() {
      if (!is.null(self$getAlternate())) {
        if (!is.null(self$getIPD())) {
          self$getIPD()$get_reference_sequence(self$getAlternate())
        } else {
          Biostrings::readDNAStringSet(self$getAltPath())
        }
      } else NULL
    },
    ##
    getNreads = function() {
      self$getConfig("nreads")
    },
    ##
    setNreads = function(nreads) {
      stopifnot(is.null(nreads) || nreads >= 1)
      self$setConfig("nreads", nreads)
      invisible(self)
    },
    ##
    getOpts = function(name = "map0") {
      if (is.null(name))
        merge_list(self$getConfig("opts"), self$getConfig("longreads")$opts, update = TRUE)
      else {
        opts <- merge_list(self$getConfig("opts"), self$getConfig("longreads")$opts, update = TRUE)
        if (is.list(opts))
          opts[[name]]
        else
          opts
      }
    },
    ##
    getIPD = function() {
      private$ipd
    },
    ##
    getPileup = function() {
      self$map0$pileup
    },
    ##
    getSnpMatrix = function() {
      self$partition$mat
    },
    ##
    getPartition = function() {
      self$partition$prt
    },
    ##
    getHapList = function(group) {
      if (missing(group)) {
        self$partition$hpl
      } else {
        self$partition$hpl[[grp]]
      }
    },
    getARefType = function() {
      private$conf$A_reftype
    },
    setARefType = function(value) {
      private$conf$A_reftype = value
    },
    getBRefType = function() {
      private$conf$B_reftype
    },
    setBRefType = function(value) {
      private$conf$B_reftype = value
    },
    ##
    getConseqs = function(group = NULL, mapn = 1) {
      group <- match.arg(group, c("A", "B"))
      if (mapn == 1) {
        ref <- self$map1[[group]]$conseq$reference %||% Biostrings::BStringSet()
        alt <- self$map1[[group]]$conseq$alternate %||% Biostrings::BStringSet()
        merged <- self$map1[[group]]$conseq$merged %||% Biostrings::BStringSet()
      } else if (mapn == 2) {
        ref <- alt <- Biostrings::BStringSet()
        merged <- self$map2[[group]]$conseq %||% Biostrings::BStringSet()
      }
      seqs <- tryCatch({
        Biostrings::DNAStringSet(c(ref, alt, merged))
      }, error = function(e) {
        warning("Possibly indels in consensus")
        Biostrings::DNAStringSet(gsub("[-+]", "", c(ref, alt, merged)))
      })
      metadata(seqs) <- compact(list(
        ref = tryCatch(
          metadata(ref)$zscore,
          error = function(e)
            NULL
        ),
        alt =  tryCatch(
          metadata(alt)$zscore,
          error = function(e)
            NULL
        ),
        merged = tryCatch(
          metadata(merged)$zscore,
          error = function(e)
            NULL
        )
      ))
      seqs
    },
    ##
    getMapTag = function(n = 0, group = NULL, ref = NULL) {
      stopifnot(is.numeric(n),
                n >= 0 && n <= 3)
      if (n == 1) {
        group <- match.arg(group, c("A", "B"))
        ref <- match.arg(ref, c("reference", "alternate", "merged", "multialign"))
      }
      if (n == 2) {
        group <- match.arg(group, c("A", "B"))
      }
      if (n == 3) {
        ref <- match.arg(group, c("LRA", "LRB", "SRA", "SRB"))
      }
      switch(n + 1L,
             self$map0$tag,
             self$map1[[group]]$tag[[ref]],
             self$map2[[group]]$tag,
             self$map3$tag[[ref]])
    },
    ##
    mergeMap1Conseqs = function(group) {
      group   <- match.arg(group, c("A", "B"))
      conseqs <- self$getConseqs(group, mapn = 1)
      zscore  <- metadata(conseqs)
      message("\n  Merging consensus seqs for group ", group)
      merge_conseqs_(conseqs, zscore)
    },
    ##
    getGroupPileup = function(group = NULL, ref = NULL, reads = "pacbio1") {
      group  <- match.arg(group, c("A", "B"))
      ref    <- match.arg(ref, c("reference", "alternate", "multialign", "LRA", "LRB", "SRA", "SRB"))
      reads  <- match.arg(reads, c("pacbio1", "pacbio2", "shotgun"))
      switch(
        reads,
        pacbio1 = self$map1[[group]]$pileup[[ref]],
        pacbio2 = self$map2[[group]]$pileup,
        shotgun = self$map3$pileup[[ref]]
      )
    },
    ##
    setConsensus = function(x) {
      stopifnot(is(x, "ConsList"))
      self$consensus = x
      invisible(self)
    },
    ##
    getMapFun = function() {
      match.fun(paste0("run_", self$getMapper()))
    },
    ##
    ## Predicate methods ####
    ##
    hasMultialign = function() {
      self$getConfig("consensus") == "multialign"
    },
    ##
    hasPileup = function() {
      tryCatch(
        is(self$map0$pileup, "pileup"),
        error = function(e)
          FALSE
      )
    },
    ##
    hasPartition = function() {
      tryCatch(
        is(self$partition$prt, "HapPart"),
        error = function(e)
          FALSE
      )
    },
    ##
    hasHapList = function() {
      tryCatch(
        is(self$partition$hpl, "HapList"),
        error = function(e)
          FALSE
      )
    },
    ##
    hasMap1Alternate = function() {
      !is.null(self$map1$A$conseq$alternate) && !is.null(self$map1$B$conseq$alternate)
    },
    ##
    ## Plotting methods ####
    ##
    ##
    plotCoverage = function(threshold,
                            range = NULL,
                            thin = 0.1,
                            width = 1,
                            label = "",
                            drop.indels = FALSE) {
      tag <- self$getMapTag()
      if (missing(threshold)) {
        threshold <- self$getThreshold()
      }
      plot_pileup_coverage(
        self$getPileup(),
        threshold,
        range,
        thin,
        width,
        label %|ch|% tag,
        drop.indels = drop.indels
      )
    },
    ##
    plotGroupCoverage = function(group = NULL,
                                 ref = NULL,
                                 reads = "pacbio1",
                                 threshold = NULL,
                                 range = NULL,
                                 thin = 0.1,
                                 width = 1,
                                 label = "",
                                 drop.indels = FALSE) {
      pileup <- self$getGroupPileup(group, ref, reads)
      lbl <- self$getMapTag(switch(
        reads,
        pacbio1 = 1,
        pacbio2 = 2,
        shotgun = 3
      ), group, ref)
      if (is.null(threshold)) {
        threshold <- self$getThreshold()
      }
      plot_pileup_coverage(
        pileup,
        threshold,
        range,
        thin,
        width,
        label %|ch|% lbl,
        drop.indels = drop.indels
      )
    },
    ##
    plotBasecallFrequency = function(threshold, label = "", drop.indels = FALSE) {
      tag <- self$getMapTag()
      if (missing(threshold)) {
        threshold <- self$getThreshold()
      }
      plot_pileup_basecall_frequency(
        self$getPileup(),
        threshold,
        label %|ch|% tag,
        drop.indels = drop.indels
      )
    },
    ##
    plotGroupBasecallFrequency = function(group = NULL,
                                          ref = NULL,
                                          reads = "pacbio1",
                                          threshold = NULL,
                                          label = "",
                                          drop.indels = FALSE) {
      pileup <- self$getGroupPileup(group, ref, reads)
      lbl <- self$getMapTag(switch(reads,
                                   pacbio1 = 1,
                                   pacbio2 = 2,
                                   shotgun = 3
      ), group, ref)
      if (is.null(threshold)) {
        threshold <- self$getThreshold()
      }
      plot_pileup_basecall_frequency(
        pileup,
        threshold,
        label %|ch|% lbl,
        drop.indels = drop.indels
      )
    },
    ##
    plotPartitionHistogram = function(label = "") {
      tag <- self$getMapTag()
      plot_partition_histogram(x = self$getPartition(), label %|ch|% tag)
    },
    ##
    plotPartitionHaplotypes = function(thin = 1, label = "") {
      tag <- self$getMapTag()
      plot_partition_haplotypes(x = self$getPartition(), thin, label %|ch|% tag)
    },
    ##
    plotConseqProbability = function(ref = NULL,
                                     reads = "pacbio1",
                                     threshold = "auto",
                                     text_size = 3,
                                     point_size = 1) {
      ref   <- match.arg(ref, c("reference", "alternate", "merged", "multialign"))
      reads <- match.arg(reads, c("pacbio1", "pacbio2", "shotgun"))
      lblA  <-
        self$getMapTag(switch(
          reads,
          pacbio1 = 1,
          pacbio2 = 2,
          shotgun = 3
        ), "A", ref)
      lblB  <-
        self$getMapTag(switch(
          reads,
          pacbio1 = 1,
          pacbio2 = 2,
          shotgun = 3
        ), "B", ref)
      cseqA <- switch(
        reads,
        pacbio1 = self$map1$A$conseq[[ref]],
        pacbio2 = self$map2$A$conseq,
        shotgun = self$map3$conseq$A
      )
      cseqB <- switch(
        reads,
        pacbio1 = self$map1$B$conseq[[ref]],
        pacbio2 = self$map2$B$conseq,
        shotgun = self$map3$conseq$B
      )
      plot_conseq_probability(cseqA, cseqB, threshold, text_size, point_size, labelA = lblA, labelB = lblB)
    },
    ##
    ## Summary methods ####
    ##
    polymorphicPositions = function(threshold) {
      if (missing(threshold)) {
        threshold <- self$getThreshold()
      }
      polymorphic_positions(self$getPileup(), threshold)
    },
    ##
    summarisePartitions = function() {
      stopifnot(self$hasHapList())
      summary(self$getHapList())
    },
    ##
    plotMap0Summary = function(thin = 0.2, width = 4, label = "") {
      tag <- self$getMapTag()
      multiplot(
        self$plotCoverage(
          thin = thin,
          width = width,
          label = label %|ch|% tag
        ),
        self$plotBasecallFrequency(threshold = self$getThreshold(), label = " "),
        layout = matrix(c(1, 2, 2, 2), ncol = 1)
      )
    },
    ##
    plotPartitionSummary = function(label = "", limits = NULL) {
      tag <- self$getMapTag()
      p1  <- self$plotPartitionHistogram(label = label %||% tag) +
        ggplot2::theme(legend.position = "none")
      p2  <- self$plotPartitionHaplotypes(thin = 1, label = " ") +
        ggplot2::theme(legend.position = "bottom")
      if (!is.null(limits)) {
        df <- dplyr::filter(p2$data, snp == 1)
        lims <- c(
          min(which(df$mcoef >= max(limits))),
          max(which(df$mcoef <= min(limits)))
        )
        p1 <- p1 +
          geom_vline(xintercept = limits, colour = "grey40",
                     linetype = "dashed", size = 1)
        p2 <- p2 +
          geom_hline(yintercept = lims, colour = "grey40",
                     linetype = "dashed", size = 1)
      }
      multiplot(p1, p2, layout = matrix(c(1, 2, 2, 2), ncol = 1))
    },
    ##
    plotMap1Summary = function(group = NULL, thin = 0.2, width = 10) {
      if (self$hasMap1Alternate()) {
        group <- match.arg(group, c("A", "B"))
        tag1 <- self$getMapTag(1, group, "reference")
        tag2 <- self$getMapTag(1, group, "alternate")
        multiplot(
          self$plotGroupCoverage(group, "reference", "pacbio1", NULL, NULL, thin, width, tag1, drop.indels = TRUE),
          self$plotGroupBasecallFrequency(group, "reference", "pacbio1", NULL, " ", drop.indels = TRUE),
          self$plotGroupCoverage(group, "alternate", "pacbio1", NULL, NULL, thin, width, tag2, drop.indels = TRUE),
          self$plotGroupBasecallFrequency(group, "alternate", "pacbio1", NULL, " ", drop.indels = TRUE),
          layout = matrix(c(1, 2, 2, 2, 3, 4, 4, 4), ncol = 2)
        )
      } else {
        ref  <- if (self$hasMultialign()) "multialign" else "reference"
        tag1 <- self$getMapTag(1, "A", ref)
        tag2 <- self$getMapTag(1, "B", ref)
        multiplot(
          self$plotGroupCoverage("A", ref, "pacbio1", NULL, NULL, thin, width, tag1, drop.indels = TRUE),
          self$plotGroupBasecallFrequency("A", ref, "pacbio1", NULL, " ", drop.indels = TRUE),
          self$plotGroupCoverage("B", ref, "pacbio1", NULL, NULL, thin, width, tag2, drop.indels = TRUE),
          self$plotGroupBasecallFrequency("B", ref, "pacbio1", NULL, " ", drop.indels = TRUE),
          layout = matrix(c(1, 2, 2, 2, 3, 4, 4, 4), ncol = 2)
        )
      }
    },
    ##
    plotMap2Summary = function(thin = 0.2, width = 10) {
      tag1 <- self$getMapTag(n = 2, group = "A")
      tag2 <- self$getMapTag(2, "B")
      multiplot(
        self$plotGroupCoverage(group = "A", ref = NULL, reads = "pacbio2",
                               threshold = NULL, range = NULL, thin, width,
                               label = tag1),
        self$plotGroupBasecallFrequency("A", NULL, "pacbio2", NULL, " "),
        self$plotGroupCoverage("B", NULL, "pacbio2", NULL, NULL, thin, width, tag2),
        self$plotGroupBasecallFrequency("B", NULL, "pacbio2", NULL, " "),
        layout = matrix(c(1, 2, 2, 2, 3, 4, 4, 4), ncol = 2)
      )
    },
    ##
    plotMap3SummaryLR = function(thin = 0.2, width = 10) {
      tag1 <- self$getMapTag(3, group = "LRA")
      tag2 <- self$getMapTag(3, group = "LRB")
      multiplot(
        self$plotGroupCoverage(group = NULL, ref = "LRA", reads = "shotgun", NULL, NULL, thin, width, tag1),
        self$plotGroupBasecallFrequency(NULL, "LRA", "shotgun", NULL, " "),
        self$plotGroupCoverage(NULL, "LRB", "shotgun", NULL, NULL, thin, width, tag2),
        self$plotGroupBasecallFrequency(NULL, "LRB", "shotgun", NULL, " "),
        layout = matrix(c(1, 2, 2, 2, 3, 4, 4, 4), ncol = 2)
      )
    },
    ##
    plotMap3SummarySR = function(thin = 0.2, width = 10) {
      tag1 <- self$getMapTag(3, group = "SRA")
      tag2 <- self$getMapTag(3, group = "SRB")
      multiplot(
        self$plotGroupCoverage(NULL, "SRA", "shotgun", NULL, NULL, thin, width, tag1),
        self$plotGroupBasecallFrequency(NULL, "SRA", "shotgun", NULL, " "),
        self$plotGroupCoverage(NULL, "SRB", "shotgun", NULL, NULL, thin, width, tag2),
        self$plotGroupBasecallFrequency(NULL, "SRB", "shotgun", NULL, " "),
        layout = matrix(c(1, 2, 2, 2, 3, 4, 4, 4), ncol = 2)
      )
    },
    ##
    plotMap1SummaryConseqProb = function(text_size = 1.75,
                                         point_size = 0.75,
                                         threshold = "auto") {
      if (self$hasMap1Alternate()) {
        multiplot(
          self$plotConseqProbability(
            ref = "reference",
            text_size = text_size,
            point_size = point_size,
            threshold = threshold
          ),
          self$plotConseqProbability(
            ref = "alternate",
            text_size = text_size,
            point_size = point_size,
            threshold = threshold
          ),
          self$plotConseqProbability(
            ref = "merged",
            text_size = text_size,
            point_size = point_size,
            threshold = threshold
          ),
          layout = matrix(c(1, 2, 3), ncol = 3)
        )
      } else {
        ref <- if (self$hasMultialign()) "multialign" else "reference"
        print(
          self$plotConseqProbability(
            ref = ref,
            text_size = text_size,
            point_size = point_size,
            threshold = threshold
          )
        )
      }

    },
    ##
    plotMap2SummaryConseqProb = function(text_size = 1.75,
                                         point_size = 0.75,
                                         threshold = "auto") {
      print(
        self$plotConseqProbability(
          ref = NULL,
          reads = "pacbio2",
          text_size = text_size,
          point_size = point_size,
          threshold = threshold
        )
      )
    },
    ##
    plotMap3SummaryConseqProb = function(text_size = 1.75,
                                         point_size = 0.75,
                                         threshold = "auto") {
      print(
        self$plotConseqProbability(
          ref = NULL,
          reads = "shotgun",
          text_size = text_size,
          point_size = point_size,
          threshold = threshold
        )
      )
    },
    ##
    getMap2ConseqPileup = function(group) {
      conseq <- self$getConseqs(group, 2)
      pileup <- self$getGroupPileup(group, reads = "pacbio2")
      cutoff <- self$map2[[group]]$params$pruning_cutoff
      cm <- consmat.pileup(pileup, freq = FALSE)
      cm <- cm[, which(.colSums(cm, NROW(cm), NCOL(cm)) > 0)]
      cm <- prune_consensus_matrix(cm, cutoff = cutoff, verbose = FALSE)
      if (!is.null(attr(cm, "pruning_position"))) {
        cm <- cm[-attr(cm, "pruning_position"), ]
      }
      dplyr::bind_cols(dplyr::data_frame(
        seq = strsplit(toString(conseq), "")[[1]],
        z   = S4Vectors::metadata(conseq)$merged,
        p   = pnorm(S4Vectors::metadata(conseq)$merged)
      ),
      as.data.frame(cm))
    },
    ##
    browseLongReadConseqs = function(...) {
      map1conseqA <- self$map1$A$conseq$merged
      map2conseqA <- self$map2$A$conseq
      map1conseqB <- self$map1$B$conseq$merged
      map2conseqB <- self$map2$B$conseq
      browse_align(c(map1conseqA, map2conseqA, map1conseqB, map2conseqB), ...)
    }
  ),
  ##
  ## Private fields ####
  ##
  private = list(
    conf      = NULL,
    ipd       = NULL,
    run_      = function(step) {
      switch(
        step,
        clear     = self$clear(),
        map0      = self$runMap0(),
        partition = self$runHaplotypePartitioning(),
        split     = self$splitReadsByHaplotype(),
        extract   = self$extractFastq(),
        map1      = self$runMap1(),
        map2      = self$runMap2(),
        map3      = self$runMap3(),
        cache     = self$cache(),
        polish    = DR2S::polish(self),
        report    = DR2S::report(self),
        stop("<", step, "> is not a valid step in the mapping pipeline")
      )
    }
  )
)


# Helpers -----------------------------------------------------------------


findReads <- function(datadir, sample_id, locus) {
  locus <- sub("^HLA-", "", toupper(locus))
  file_pattern <- paste0("^", sample_id, "_", locus, ".+", "fastq(\\.gz)?$")
  read_path <- dir(datadir, pattern = file_pattern, full.names = TRUE)
  read_path <- read_path[grep(pattern = "^((?!_trimmed.fastq).)*$", read_path, perl = TRUE)]
  if (length(read_path) > 0) {
    normalizePath(read_path, mustWork = TRUE)
  } else read_path
}


findLocus <- function(locus) {
  stopifnot(requireNamespace("IPDdata", quietly = TRUE))
  IPDdata::loadIPDdata(locus)
}
